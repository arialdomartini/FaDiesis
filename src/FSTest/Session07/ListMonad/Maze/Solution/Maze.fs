module FSTest.Session07.ListMonad.Maze.Solution.Maze

open ListMonad

type Direction = Up | Down | Left | Right
type Position = int * int

let movePos (x, y) direction =
    match direction with
    | Up -> (x, y + 1)
    | Down -> (x, y - 1)
    | Left -> (x - 1, y)
    | Right -> (x + 1, y)

let isValid (rows, cols) (x, y) (walls: Set<Position>) =
    x >= 0 && x < cols && y >= 0 && y < rows && not (walls.Contains(x, y))

let findAllPaths (rows, cols) (start: Position) (walls: Set<Position>) =
    let isExit (x,y) =
        x = 0
        || x = rows - 1
        || y = 0
        || y = cols - 1
    
    let rec explore current path visited =
        list {
            if current |> isExit then
                return List.rev (current :: path)
            else
                let! nextDir = [Up; Down; Left; Right]
                let nextPos = movePos current nextDir

                if isValid (rows, cols) nextPos walls && not (Set.contains nextPos visited) then
                    let newVisited = Set.add nextPos visited
                    let! result = explore nextPos (current :: path) newVisited
                    return result
        }

    explore start [] (Set.singleton start)

open Xunit
open Swensen.Unquote

(*
7 ■■■■■■▫■
6 ■▫▫▫■■▫■
5 ■▫■■■■▫■
4 ■▫■■■▫▫■　
3 ■▫▫▫▫▫■■
2 ■■■■▫■■■
1 ■▫▫▫▫■■■
0 ■■■■■■■■
  01234567
*)

[<Fact>]
let ``find the exit!`` () =

    let walls = set [

        (0,7); (1,7); (2,7); (3,7); (4,7); (5,7);        (7,7);
        (0,6);                      (4,6); (5,6);        (7,6);
        (0,5);        (2,5); (3,5); (4,5); (5,5);        (7,5);
        (0,4);        (2,4); (3,4); (4,4);               (7,4);
        (0,3);                                    (6,3); (7,3);
        (0,2); (1,2); (2,2); (3,2);        (5,2); (6,2); (7,2);
        (0,1);                              (5,1); (6,1); (7,1);
        (0,0); (1,0); (2,0); (3,0); (4,0); (5,0); (6,0); (7,0);
    ]


    let paths = findAllPaths (7, 7) (3,6) walls

    test <@ paths |> List.length = 1 @>

(*
17 ■■■■■■■■■■■■■■■■■■
16 ■■■■☆■■■■■■■■■■■■■
15 ■▫▫▫▫▫▫▫▫▫▫▫▫■■■▫■
14 ■■■■▫■■■■■■■▫■■■▫■
13 ■■■■▫■■■■▫▫▫▫■■■▫■
12 ■■■■▫▫▫▫▫■■■▫■■■▫■
11 ■■■■■■■■▫■■■▫■■■▫■
10 ■■▫▫▫▫■■▫■■■▫■■■▫■
09 ■■▫■■■■■■■■■▫■■■▫■
08 ■■▫■■■▫▫▫▫■■▫▫▫▫▫■
07 ■▫▫▫▫▫▫■■▫■■■■■▫■■
06 ■▫■■■■■■■▫■■■■■▫■■
05 ■▫■■▫▫▫▫▫▫▫▫▫▫▫▫▫■
04 ■▫■■■■■■■■■■■■■■■■
03 ■▫▫▫▫▫▫▫▫▫▫▫▫■■■▫■
02 ■■■■■■■■■▫■■▫■■■▫■
01 ■▫▫▫▫▫▫▫▫▫■■▫▫▫▫▫■
00 ■▫■■■■■■■■■■■■■■■■

*)

[<Fact>]
let ``find the exit, large maze`` () =

    let walls = set [
        (0,17); (1,17); (2,17); (3,17); (4,17); (5,17); (6,17); (7,17); (8,17); (9,17); (10,17); (11,17); (12,17); (13,17); (14,17); (15,17); (16,17); (17,17);
        (0,16); (1,16); (2,16); (3,16);         (5,16); (6,16); (7,16); (8,16); (9,16); (10,16); (11,16); (12,16); (13,16); (14,16); (15,16); (16,16); (17,16);
        (0,15);                                                                                                    (13,15); (14,15); (15,15);          (17,15);
        (0,14); (1,14); (2,14); (3,14);         (5,14); (6,14); (7,14); (8,14); (9,14); (10,14); (11,14);          (13,14); (14,14); (15,14);          (17,14);
        (0,13); (1,13); (2,13); (3,13);         (5,13); (6,13); (7,13); (8,13);                                    (13,13); (14,13); (15,13);          (17,13);
        (0,12); (1,12); (2,12); (3,12);                                         (9,12); (10,12); (11,12);          (13,12); (14,12); (15,12);          (17,12);
        (0,11); (1,11); (2,11); (3,11); (4,11); (5,11); (6,11); (7,11);         (9,11); (10,11); (11,11);          (13,11); (14,11); (15,11);          (17,11);
        (0,10); (1,10);                                 (6,10); (7,10);         (9,10); (10,10); (11,10);          (13,10); (14,10); (15,10);          (17,10);
        (0,9);  (1,9);          (3,9);  (4,9);  (5,9);  (6,9);  (7,9);  (8,9);  (9,9);  (10,9);  (11,9);           (13,9);  (14,9);  (15,9);           (17,9);
        (0,8);  (1,8);          (3,8);  (4,8);  (5,8);                                  (10,8);  (11,8);                                               (17,8);
        (0,7);                                                  (7,7);  (8,7);          (10,7);  (11,7);  (12,7);  (13,7);  (14,7);           (16,7);  (17,7);
        (0,6);          (2,6);  (3,6);  (4,6);  (5,6);  (6,6);  (7,6);  (8,6);          (10,6);  (11,6);  (12,6);  (13,6);  (14,6);           (16,6);  (17,6);
        (0,5);          (2,5);  (3,5);                                                                                                                 (17,5);
        (0,4);          (2,4);  (3,4);  (4,4);  (5,4);  (6,4);  (7,4);  (8,4);  (9,4);  (10,4);  (11,4);  (12,4);  (13,4);  (14,4);  (15,4);  (16,4);  (17,4);
        (0,3);                                                                                                     (13,3);  (14,3);  (15,3);           (17,3);
        (0,2);  (1,2);  (2,2);  (3,2);  (4,2);  (5,2);  (6,2);  (7,2);  (8,2);          (10,2);  (11,2);           (13,2);  (14,2);  (15,2);           (17,2);
        (0,1);                                                                          (10,1);  (11,1);                                               (17,1);
        (0,0);          (2,0);  (3,0);  (4,0);  (5,0);  (6,0);  (7,0);  (8,0);  (9,0);  (10,0);  (11,0);  (12,0);  (13,0);  (14,0);  (15,0);  (16,0);  (17,0);
    ]


    let exit =
        [(4, 16);(4, 15); (5, 15); (6, 15); (7, 15); (8, 15); (9, 15); (10, 15);
          (11, 15); (12, 15); (12, 14); (12, 13); (12, 12); (12, 11); (12, 10); (12, 9);
          (12, 8); (13, 8); (14, 8); (15, 8); (15, 7); (15, 6); (15, 5); (14, 5);
          (13, 5); (12, 5); (11, 5); (10, 5); (9, 5); (9, 6); (9, 7); (9, 8); (8, 8);
          (7, 8); (6, 8); (6, 7); (5, 7); (4, 7); (3, 7); (2, 7); (1, 7); (1, 6); (1, 5);
          (1, 4); (1, 3); (2, 3); (3, 3); (4, 3); (5, 3); (6, 3); (7, 3); (8, 3); (9, 3);
          (9, 2); (9, 1); (8, 1); (7, 1); (6, 1); (5, 1); (4, 1); (3, 1); (2, 1); (1, 1);
          (1, 0)]

    let paths = findAllPaths (18, 18) (4,16) walls

    test <@ paths |> List.exactlyOne = exit @>
